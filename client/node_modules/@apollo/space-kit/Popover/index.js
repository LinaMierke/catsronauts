'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _tslib = require('../_tslib-bcbe0269.js');
require('@emotion/core');
var React = require('react');
var React__default = _interopDefault(React);
require('../fonts/fonts.js');
require('../base-1dde5d6e.js');
require('../mono-f4fb9dce.js');
require('../colors/colors.js');
require('classnames');
require('../SpaceKitProvider/index.js');
require('../tippy-e2469a97.js');
var index$1 = require('../index-d84dc70c.js');
require('@tippyjs/react');
var TippyPopoverStyles = require('./popover/TippyPopoverStyles.js');
require('@popperjs/core/lib/utils/computeAutoPlacement');
require('@popperjs/core/lib/utils/detectOverflow');
require('@popperjs/core/lib/utils/getOppositePlacement');
require('@popperjs/core/lib/utils/getOppositeVariationPlacement');
var sizeModifier = require('./popover/sizeModifier.js');

var Popover = function (_a) {
    var fallbackPlacements = _a.fallbackPlacements, content = _a.content, popperOptions = _a.popperOptions, trigger = _a.trigger, _b = _a.triggerEvents, triggerEvents = _b === void 0 ? "mousedown" : _b, interactive = _a.interactive, props = _tslib.__rest(_a, ["fallbackPlacements", "content", "popperOptions", "trigger", "triggerEvents", "interactive"]);
    var instanceRef = React__default.useRef();
    /**
     * Callback to handle descendent `ListItem` clicks.
     *
     * When we have nested lists and toggle lists we might need to change how this
     * behaves.
     */
    var handleClick = React__default.useCallback(function (element) {
        var _a;
        if (interactive || element.target === element.currentTarget) {
            // We're listening for clicks on descendents so ignore events that come
            // from the element with the listener.
            return;
        }
        // how do we know if we want to hide the list?
        (_a = instanceRef.current) === null || _a === void 0 ? void 0 : _a.hide();
    }, [interactive]);
    return (React__default.createElement(React__default.Fragment, null,
        React__default.createElement(TippyPopoverStyles.TippyPopoverStyles, null),
        React__default.createElement(index$1.AbstractTooltip, _tslib.__assign({ appendTo: "parent", offset: [0, 2], onCreate: function (instance) {
                instanceRef.current = instance;
            }, content: React__default.createElement("span", { onClick: handleClick }, content), hideOnClick: true, theme: "space-kit-list", trigger: triggerEvents, popperOptions: _tslib.__assign(_tslib.__assign({ strategy: "fixed" }, popperOptions), { modifiers: _tslib.__spreadArrays([
                    // Disable `flip` because we're using our new version
                    { name: "flip", enabled: false },
                    {
                        name: "findTippyBox",
                        phase: "read",
                        enabled: true,
                        fn: function (_a) {
                            var name = _a.name, state = _a.state;
                            var element = state.elements.popper.querySelector(".tippy-box");
                            state.modifiersData[name].boxElement = element;
                        },
                    },
                    sizeModifier.sizeModifier,
                    {
                        name: "maxSize",
                        requires: ["findTippyBox"],
                        options: { padding: 7, fallbackPlacements: fallbackPlacements },
                    },
                    {
                        name: "applyMaxSize",
                        enabled: true,
                        phase: "beforeWrite",
                        requires: ["maxSize", "findTippyBox"],
                        fn: function (_a) {
                            var state = _a.state;
                            var maxHeight = state.modifiersData.maxSize.height;
                            /**
                             * We read this element in the `findTippyBox` phase. We need to
                             * use some custom logic here to apply the style to the tippy
                             * box because usually that's not made available. We _could_
                             * apply these styles directly to the `popper` element and, but
                             * then the border will be swallowed by the overflow. If we put
                             * the border on `popper`, then the border will not be animated
                             * because animations are applied to `.tippy-box`.
                             */
                            var element = state.modifiersData.findTippyBox.boxElement;
                            if (element) {
                                element.style.maxHeight = maxHeight + "px";
                                element.style.overflow = "auto";
                            }
                        },
                    }
                ], ((popperOptions === null || popperOptions === void 0 ? void 0 : popperOptions.modifiers) || [])) }) }, props, { interactive: true }), trigger)));
};

exports.Popover = Popover;
//# sourceMappingURL=index.js.map
