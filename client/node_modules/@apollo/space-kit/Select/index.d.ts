import React, { ChangeEvent } from "react";
import { Button } from "../Button";
import { Popover } from "../Popover";
export declare type OptionProps = Omit<React.DetailedHTMLProps<React.OptionHTMLAttributes<HTMLOptionElement>, HTMLOptionElement>, "children"> & {
    children: string;
};
interface Props extends Pick<React.ComponentProps<typeof Popover>, "disabled" | "maxWidth" | "placement" | "popperOptions" | "matchTriggerWidth">, Pick<React.ComponentProps<typeof Button>, "className" | "feel" | "style">, Pick<React.DetailedHTMLProps<React.SelectHTMLAttributes<HTMLSelectElement>, HTMLSelectElement>, "onChange" | "name" | "id"> {
    disabled?: boolean;
    label?: React.ReactElement;
    /**
     * Callback called when the selected item changes
     *
     * This will be called syncronously after you try to close the menu. If you
     * are running a long-running task, like fetching data or parseing something
     * as the result of this handler; you might want to wrap your callback in a
     * `setTimeout(... ,0)`.
     */
    onChange?: (event: ChangeEvent<HTMLSelectElement>) => void;
    /**
     * Item currently selected
     *
     * While I believe it's also valid to use the `<option>`'s `selected` prop; we
     * are not using that here. We _might_ use that if we render a native `select`
     * element in the future.
     */
    value?: NonNullable<OptionProps["value"]> | null;
    /** Default value for a non-controlled component */
    defaultValue?: NonNullable<OptionProps["value"]> | null;
    size?: "auto" | "small" | "medium" | "extra large";
}
export declare const Select: React.FC<Props>;
export {};
