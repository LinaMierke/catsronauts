'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _tslib = require('../_tslib-bcbe0269.js');
var core = require('@emotion/core');
var React = require('react');
var React__default = _interopDefault(React);
require('../fonts/fonts.js');
var base$1 = require('../base-1dde5d6e.js');
require('../mono-f4fb9dce.js');
var colors = require('../colors/colors.js');
var assertUnreachable = require('../assertUnreachable-18645656.js');
require('../colors/utils/findPaletteByColor.js');
var getOffsetInPalette = require('../colors/utils/getOffsetInPalette.js');
var tinycolor = _interopDefault(require('tinycolor2'));
require('../SpaceKitProvider/index.js');
var LoadingSpinner = require('../Loaders/LoadingSpinner.js');
var focus = require('@react-aria/focus');
var utils = require('@react-aria/utils');
var omit = _interopDefault(require('lodash/omit'));
var ButtonIcon = require('./button/ButtonIcon.js');

/**
 * Save a default color so we can check if we used the default or not. The
 * default color has a few special properties.
 */
var defaultColor = colors.colors.silver.light;
/**
 * Get the button's text color
 */
function getTextColor(_a) {
    var color = _a.color, feel = _a.feel, theme = _a.theme, mode = _a.mode;
    // Text color will always be the same for secondary buttons
    if (color === colors.colors.white) {
        return colors.colors.grey.darker;
    }
    switch (feel) {
        case "raised":
            // Set the base (meaning no pseudo-selectors) text color for raised
            // buttons. Otherwise return `undefined` to not change the color.
            //
            // We have some special logic for the raised color; set the text color to
            // be what is most readable between white and the default text color and
            // the _hover_ color's background. This is overrideable by the user, but
            // it shouldn't need to be.
            return !mode
                ? tinycolor
                    .mostReadable(getHoverBackgroundColor({ color: color, feel: feel, theme: theme }), [colors.colors.white, colors.colors.grey.darker], {
                    level: "AA",
                    size: "small",
                })
                    .toString()
                : undefined;
        case "flat":
            if (color === defaultColor) {
                return theme === "dark" ? colors.colors.grey.light : colors.colors.grey.darker;
            }
            // We have a custom color and we're in dark mode, lighten the base and
            // focused colors 1 shade.
            if (theme === "dark" && (!mode || mode === ":focus")) {
                return getOffsetInPalette.getOffsetInPalette(1, "lighter", color);
            }
            return color;
        /* istanbul ignore next */
        default:
            throw assertUnreachable.assertUnreachable(feel);
    }
}
/**
 * Get the button's height
 */
function getHeight(_a) {
    var size = _a.size;
    switch (size) {
        case "small":
            return 28;
        case "default":
            return 36;
        case "large":
            return 42;
        /* istanbul ignore next */
        default:
            throw assertUnreachable.assertUnreachable(size);
    }
}
/**
 * Get the hover background color
 */
function getHoverBackgroundColor(_a) {
    var color = _a.color, feel = _a.feel, theme = _a.theme;
    if (color === colors.colors.white) {
        // Special case for secondary buttons
        return colors.colors.silver.light;
    }
    switch (feel) {
        case "flat":
            // Hardcode if we're using the default color (special case), otherwise get
            // the next lightest color.
            if (color === defaultColor) {
                return theme === "light" ? colors.colors.silver.light : colors.colors.grey.dark;
            }
            return getOffsetInPalette.getOffsetInPalette(Infinity, "lighter", color);
        case "raised":
            // One shade darker
            return getOffsetInPalette.getOffsetInPalette(1, "darker", color);
        /* istanbul ignore next */
        default:
            throw assertUnreachable.assertUnreachable(feel);
    }
}
/**
 * Style system for Space Kit buttons
 *
 * This is intended to be used as an abstraction for your project's style guide.
 *
 * @see https://zpl.io/amdN6Pr
 */
var Button = React__default.forwardRef(function (_a, ref) {
    var _b = _a.as, as = _b === void 0 ? React__default.createElement("button", null) : _b, children = _a.children, _c = _a.color, color = _c === void 0 ? defaultColor : _c, variant = _a.variant, endIcon = _a.endIcon, _d = _a.feel, feel = _d === void 0 ? "raised" : _d, iconProp = _a.icon, loading = _a.loading, _e = _a.size, size = _e === void 0 ? "default" : _e, _f = _a.theme, theme = _f === void 0 ? "light" : _f, passthroughProps = _tslib.__rest(_a, ["as", "children", "color", "variant", "endIcon", "feel", "icon", "loading", "size", "theme"]);
    var _g = focus.useFocusRing(), isFocusVisible = _g.isFocusVisible, focusProps = _g.focusProps;
    var mergedProps = utils.mergeProps(passthroughProps, as.props, focusProps, {
        ref: ref,
    });
    /**
     * If the button is in a `loading` state, then always treat it as
     * disabled. Otherwise, try to use `as.props`. Finally, use `props`
     */
    mergedProps.disabled = loading || mergedProps.disabled;
    /**
     * Handler to avoid responding to click events for all attached listeners
     * when `disabled`
     */
    var onClick = function (event) {
        var _a;
        // If the button is disabled, then don't propogate `onClick`
        // events.
        if (mergedProps.disabled)
            return event.preventDefault();
        (_a = mergedProps.onClick) === null || _a === void 0 ? void 0 : _a.call(mergedProps, event);
    };
    var focusedStyles = _tslib.__assign(_tslib.__assign({}, (feel === "flat" && {
        backgroundColor: theme === "light" ? colors.colors.white : "#000",
        color: theme === "light" ? colors.colors.blue.base : colors.colors.blue.light,
    })), { 
        // The `box-shadow` property is copied directly from Zeplin for the
        // light theme. For the dark theme we use a variant of the color to
        // make the borders sharp.
        boxShadow: "0 1px 4px 0 rgba(18, 21, 26, 0.08), 0 0 0 2px " + (theme === "light" || color === defaultColor || color === colors.colors.white
            ? "#bbdbff"
            : getOffsetInPalette.getOffsetInPalette(Infinity, "lighter", color)) + ", inset 0 0 0 1px " + (color === defaultColor || color === colors.colors.white
            ? "#2075d6"
            : getOffsetInPalette.getOffsetInPalette(1, "darker", color)) + ", inset 0 -1px 0 0 rgba(18, 21, 26, 0.05)" });
    var icon = loading ? (React__default.createElement(LoadingSpinner.LoadingSpinner, { size: "2xsmall", theme: theme === "light" ? "grayscale" : "dark" })) : (iconProp);
    /**
     * Icon size in pixels
     *
     * This is stored so we can use the same value for `height` and `width`
     */
    var iconSize = size === "small" ? 12 : size === "large" ? 24 : 16;
    var iconOnly = !children;
    if (variant === "fab") {
        if (!icon) {
            throw new TypeError("FAB buttons are required to have an `icon`");
        }
        else if (children) {
            throw new TypeError("FAB buttons cannot have children, only an `icon`");
        }
    }
    return (React__default.createElement(core.ClassNames, null, function (_a) {
        var cx = _a.cx, css = _a.css;
        var propsToPass = utils.mergeProps(
        // Omit `onClick` from `otherProps` beacuse we'll be conditionally
        // calling it in the `onClick` handler depending on the `disabled`
        // prop. Also exclude `className` beacuse we'll be combining it on
        // our own with `cx`. This is necessary because `cx` allows for
        // emotion styles to be logically overwritten.
        omit(mergedProps, "className", "onClick"), {
            onClick: onClick,
            className: cx(css([
                _tslib.__assign(_tslib.__assign(_tslib.__assign(_tslib.__assign({ 
                    // We need to also set the `:hover` on `:disabled` so it has a
                    // higher specificity than any `:hover` classes passed in. This
                    // also means that both of these need to be overriden if we want
                    // to use a custom disabled color.
                    "&[disabled], &[disabled]:hover": {
                        backgroundColor: feel === "flat"
                            ? "transparent"
                            : theme === "light"
                                ? colors.colors.silver.light
                                : colors.colors.grey.dark,
                        boxShadow: "none",
                        color: feel === "flat" && theme === "dark"
                            ? colors.colors.grey.dark
                            : colors.colors.grey.light,
                    }, backgroundColor: color === colors.colors.white
                        ? colors.colors.white
                        : feel === "raised"
                            ? color
                            : "transparent", borderRadius: variant === "fab" ? "100%" : 4, borderWidth: 0 }, (feel !== "flat" && {
                    boxShadow: theme === "light"
                        ? "0 1px 4px 0 rgba(18, 21, 26, 0.04), inset 0 0 0 1px rgba(18, 21, 26, 0.2), inset 0 -1px 0 0 rgba(18, 21, 26, 0.05)"
                        : "0 0 0 1px rgba(18, 21, 26, 0.2), 0 1px 4px 0 rgba(18, 21, 26, 0.08), 0 1px 0 0 rgba(18, 21, 26, 0.05)",
                })), { color: getTextColor({ color: color, feel: feel, theme: theme }), cursor: mergedProps.disabled ? "default" : "pointer", 
                    // Vertically center children
                    display: "inline-flex", alignItems: "center", justifyContent: "center", height: getHeight({ size: size }), minWidth: iconOnly
                        ? size === "small"
                            ? 28
                            : size === "default"
                                ? 36
                                : size === "large"
                                    ? 42
                                    : assertUnreachable.assertUnreachable(size)
                        : endIcon
                            ? 0
                            : size === "small"
                                ? 76
                                : size === "default"
                                    ? 100
                                    : size === "large"
                                        ? 112
                                        : assertUnreachable.assertUnreachable(size), 
                    // We have to set the Y padding because browsers (at least Chrome) has
                    // a non-symmetrical vertical padding applied by default.
                    paddingLeft: iconOnly ? 0 : 12, paddingRight: iconOnly ? 0 : endIcon ? 8 : 12 }), (size === "small"
                    ? base$1.small
                    : size === "large"
                        ? base$1.large
                        : base$1.base)), { fontWeight: 600, 
                    // Disable the outline because we're setting a custom `:active` style
                    outline: 0, textDecoration: "none", whiteSpace: "nowrap" }),
                !mergedProps.disabled && {
                    ":hover, &[data-force-hover-state]": _tslib.__assign({ backgroundColor: getHoverBackgroundColor({
                            color: color,
                            feel: feel,
                            theme: theme,
                        }), color: getTextColor({
                            color: color,
                            feel: feel,
                            theme: theme,
                            mode: ":hover",
                        }) }, (feel !== "flat" && {
                        // The `box-shadow` property is copied directly from Zeplin
                        boxShadow: theme === "light"
                            ? "0 5px 10px 0 rgba(18, 21, 26, 0.08), inset 0 0 0 1px rgba(18, 21, 26, 0.2), inset 0 -1px 0 0 rgba(18, 21, 26, 0.05)"
                            : "0 0 0 1px rgba(18, 21, 26, 0.2), 0 5px 10px 0 rgba(18, 21, 26, 0.12), 0 1px 0 0 rgba(18, 21, 26, 0.05)",
                    })),
                    // This is kind of hacky behavior
                    "&[data-force-focus-state]": focusedStyles,
                    "&:active, &[data-force-active-state], &[aria-expanded=true]": _tslib.__assign(_tslib.__assign({}, (getTextColor({
                        color: color,
                        feel: feel,
                        theme: theme,
                        mode: ":hover",
                    }) && {
                        color: getTextColor({
                            color: color,
                            feel: feel,
                            theme: theme,
                            mode: ":active",
                        }),
                    })), { backgroundColor: color === colors.colors.white
                            ? colors.colors.white
                            : feel === "raised"
                                ? color
                                : color === defaultColor
                                    ? theme === "dark"
                                        ? colors.colors.grey.darker
                                        : colors.colors.silver.base
                                    : getOffsetInPalette.getOffsetInPalette(2, "lighter", color), 
                        // The `box-shadow` properties are copied directly from Zeplin
                        boxShadow: feel !== "flat"
                            ? theme === "light"
                                ? "inset 0 0 0 1px rgba(18, 21, 26, 0.2), inset 0 -1px 0 0 rgba(18, 21, 26, 0.05), inset 0 2px 2px 0 rgba(18, 21, 26, 0.12)"
                                : "0 0 0 1px rgba(18, 21, 26, 0.2), 0 1px 4px 0 rgba(18, 21, 26, 0.08), 0 -1px 0 0 rgba(18, 21, 26, 0.16), inset 0 1px 2px 0 rgba(18, 21, 26, 0.42)"
                            : "none", outline: "0" }),
                },
            ]), mergedProps.className, isFocusVisible && css(focusedStyles)),
            children: (React__default.createElement(React__default.Fragment, null,
                icon && (React__default.createElement(ButtonIcon.ButtonIcon, { iconSize: iconSize, className: css({ margin: iconOnly ? 0 : "0 4px 0" }) }, icon)),
                children,
                endIcon && !loading && (React__default.createElement(ButtonIcon.ButtonIcon, { iconSize: iconSize, className: css({ margin: iconOnly ? 0 : "0 0 0 6px" }) }, endIcon)))),
        });
        return React__default.cloneElement(as, propsToPass);
    }));
});

exports.Button = Button;
//# sourceMappingURL=Button.js.map
